DATA SEGMENT
is_even_num DB 0
num DW 0
is_number_prime DB 0
number DW 0
fibo_res DW 0
index DW 0
result DW 0
num2 DW 0
num1 DW 0
GLOBAL_STRING_0 DB 'Power Function:', 0DH, 0AH, '$'
GLOBAL_STRING_1 DB 'Number to power: ', 0DH, 0AH, '$'
GLOBAL_STRING_2 DB 'Power by: ', 0DH, 0AH, '$'
GLOBAL_STRING_3 DB 'Result:', 0DH, 0AH, '$'
GLOBAL_STRING_4 DB 'Fibonachi Function: ', 0DH, 0AH, '$'
GLOBAL_STRING_5 DB 'Input fibonachi index: ', 0DH, 0AH, '$'
GLOBAL_STRING_6 DB 'Prime Function: ', 0DH, 0AH, '$'
GLOBAL_STRING_7 DB 'Enter Number to find if he is prime: ', 0DH, 0AH, '$'
GLOBAL_STRING_8 DB 'Number Is Prime!', 0DH, 0AH, '$'
GLOBAL_STRING_9 DB 'Number Is Not Prime!', 0DH, 0AH, '$'
GLOBAL_STRING_10 DB 'Even Function: ', 0DH, 0AH, '$'
GLOBAL_STRING_11 DB 'enter a number to find if hes even: ', 0DH, 0AH, '$'
GLOBAL_STRING_12 DB 'number is even', 0DH, 0AH, '$'
GLOBAL_STRING_13 DB 'number is not even', 0DH, 0AH, '$'
INVALID_NUMBER_INPUT DB 0DH, 0AH, 'Input was not a number! Start Over', 0DH, 0AH, '$'
NEW_LINE_CHARS DB 0DH, 0AH, '$'
NUMBER_OUT_PUT_BUFFER DB 8 DUP(?)
DATA ENDS
STACK_SEG SEGMENT STACK
DW 1000H DUP(?)
STACK_SEG ENDS
CODE SEGMENT
ASSUME CS : CODE, DS : DATA, SS : STACK_SEG
START:
MOV AX, DATA
MOV DS, AX
MOV BP, SP
SUB SP, 22
BLOCK0:
LEA AX, GLOBAL_STRING_0
CALL PRINTSTRING
LEA AX, GLOBAL_STRING_1
CALL PRINTSTRING
CALL GETNUM
MOV WORD PTR num1, AX
LEA AX, GLOBAL_STRING_2
CALL PRINTSTRING
CALL GETNUM
MOV WORD PTR num2, AX
PUSH WORD PTR num2
PUSH WORD PTR num1
CALL BLOCK1 
MOV BP[-2], BX
JMP BLOCK8 
BLOCK1:
PUSH BP
MOV BP, SP
SUB SP, 44
MOV AX, WORD PTR BP[+4]
MOV BP[-2], AX
MOV AX, WORD PTR BP[+6]
MOV BP[-4], AX
CMP WORD PTR BP[-4] , 0 
JLE YES0 
MOV BL, 0 
JMP CON0 
YES0:
MOV BL, 1 
CON0:
TEST BL, 1 
JNZ BLOCK3 
JMP BLOCK4 
BLOCK3:
MOV BX, 1
JMP BLOCK2
BLOCK2:
ADD SP, 44
POP BP
RET 4
BLOCK5:
MOV AX, WORD PTR BP[-12]  
MOV WORD PTR BP[-8] , AX 
MOV BP[-16], CX
MOV AX, WORD PTR BP[-4]  
MOV CX, 2 
XOR DX, DX
DIV CX 
MOV CX, DX 
MOV BP[-16], CX
CMP CX, 0 
JE YES1 
MOV CL, 0 
JMP CON1 
YES1:
MOV CL, 1 
CON1:
TEST CL, 1 
JNZ BLOCK6 
JMP BLOCK7 
BLOCK6:
MOV BP[-14], DX
MOV AX, WORD PTR BP[-8]  
XOR DX, DX
IMUL WORD PTR BP[-8]  
MOV DX, AX 
MOV BX, DX
JMP BLOCK2
BLOCK7:
MOV BP[-14], DX
MOV AX, WORD PTR BP[-8]  
XOR DX, DX
IMUL WORD PTR BP[-8]  
MOV WORD PTR BP[-20] , AX 
MOV BP[-14], DX
MOV AX, WORD PTR BP[-20]  
XOR DX, DX
IMUL WORD PTR BP[-2]  
MOV WORD PTR BP[-22] , AX 
MOV BX, WORD PTR BP[-22] 
JMP BLOCK2
BLOCK8:
MOV AX, WORD PTR BP[-2]  
MOV WORD PTR result, AX 
LEA AX, GLOBAL_STRING_3
CALL PRINTSTRING
MOV AX, WORD PTR result
CALL PRINTNUM
LEA AX, GLOBAL_STRING_4
CALL PRINTSTRING
LEA AX, GLOBAL_STRING_5
CALL PRINTSTRING
CALL GETNUM
MOV WORD PTR index, AX
PUSH WORD PTR index
MOV BP[-5], BL
MOV BP[-17], CL
MOV BP[-14], DX
CALL BLOCK9 
MOV BP[-4], BX
JMP BLOCK17 
BLOCK9:
PUSH BP
MOV BP, SP
SUB SP, 28
MOV AX, WORD PTR BP[+4]
MOV BP[-2], AX
CMP WORD PTR BP[-2] , 0 
JE YES2 
MOV BL, 0 
JMP CON2 
YES2:
MOV BL, 1 
CON2:
TEST BL, 1 
JNZ BLOCK11 
JMP BLOCK12 
BLOCK11:
MOV BX, 0
JMP BLOCK10
BLOCK10:
ADD SP, 28
POP BP
RET 2
BLOCK15:
MOV CX, WORD PTR BP[-2]  
SUB CX, 2 
PUSH CX
MOV BP[-3], BL
MOV BP[-10], CX
CALL BLOCK9 
MOV BP[-12], BX
JMP BLOCK16 
BLOCK16:
MOV BX, WORD PTR BP[-8]  
ADD BX, WORD PTR BP[-12]  
MOV BX, BX
JMP BLOCK10
BLOCK17:
MOV AX, WORD PTR BP[-4]  
MOV WORD PTR fibo_res, AX 
MOV AX, WORD PTR fibo_res
CALL PRINTNUM
LEA AX, GLOBAL_STRING_6
CALL PRINTSTRING
LEA AX, GLOBAL_STRING_7
CALL PRINTSTRING
CALL GETNUM
MOV WORD PTR number, AX
PUSH WORD PTR number
MOV BP[-14], BX
CALL BLOCK18 
MOV BP[-6], BX
JMP BLOCK30 
BLOCK18:
PUSH BP
MOV BP, SP
SUB SP, 30
MOV AX, WORD PTR BP[+4]
MOV BP[-2], AX
CMP WORD PTR BP[-2] , 0 
JLE YES3 
MOV BL, 0 
JMP CON3 
YES3:
MOV BL, 1 
CON3:
TEST BL, 1 
JNZ BLOCK20 
JMP BLOCK21 
BLOCK20:
MOV BX, 0
JMP BLOCK19
BLOCK19:
ADD SP, 30
POP BP
RET 2
BLOCK30:
MOV AX, WORD PTR BP[-6]  
MOV BYTE PTR is_number_prime, AL 
CMP BYTE PTR is_number_prime, 1 
JE YES4 
MOV CL, 0 
JMP CON4 
YES4:
MOV CL, 1 
CON4:
TEST CL, 1 
JNZ BLOCK31 
JMP BLOCK32 
BLOCK31:
LEA AX, GLOBAL_STRING_8
CALL PRINTSTRING
JMP BLOCK33 
BLOCK33:
LEA AX, GLOBAL_STRING_10
CALL PRINTSTRING
LEA AX, GLOBAL_STRING_11
CALL PRINTSTRING
CALL GETNUM
MOV WORD PTR num, AX
PUSH WORD PTR num
MOV BP[-3], BL
MOV BP[-7], CL
CALL BLOCK34 
MOV BP[-10], BX
JMP BLOCK39 
BLOCK34:
PUSH BP
MOV BP, SP
SUB SP, 14
MOV AX, WORD PTR BP[+4]
MOV BP[-2], AX
MOV AX, 1 
MOV BYTE PTR BP[-3] , AL 
JMP BLOCK36 
BLOCK36:
CMP WORD PTR BP[-2] , 0 
JG YES5 
MOV BL, 0 
JMP CON5 
YES5:
MOV BL, 1 
CON5:
TEST BL, 1 
JNZ BLOCK37 
JMP BLOCK38 
BLOCK37:
CMP BYTE PTR BP[-3] , 1 
JNE YES6 
MOV CL, 0 
JMP CON6 
YES6:
MOV CL, 1 
CON6:
MOV BYTE PTR BP[-3] , CL 
MOV CX, WORD PTR BP[-2]  
SUB CX, 1 
MOV WORD PTR BP[-2] , CX 
JMP BLOCK36 
BLOCK38:
MOV BL, BYTE PTR BP[-3] 
JMP BLOCK35
BLOCK35:
ADD SP, 14
POP BP
RET 2
BLOCK39:
MOV AX, WORD PTR BP[-10]  
MOV BYTE PTR is_even_num, AL 
CMP BYTE PTR is_even_num, 1 
JE YES7 
MOV CL, 0 
JMP CON7 
YES7:
MOV CL, 1 
CON7:
TEST CL, 1 
JNZ BLOCK40 
JMP BLOCK41 
BLOCK40:
LEA AX, GLOBAL_STRING_12
CALL PRINTSTRING
JMP BLOCK42 
BLOCK42:
MOV AX, 4C00H
INT 21H
BLOCK41:
LEA AX, GLOBAL_STRING_13
CALL PRINTSTRING
JMP BLOCK42 
BLOCK32:
LEA AX, GLOBAL_STRING_9
CALL PRINTSTRING
JMP BLOCK33 
BLOCK21:
CMP WORD PTR BP[-2] , 3 
JLE YES8 
MOV DL, 0 
JMP CON8 
YES8:
MOV DL, 1 
CON8:
TEST DL, 1 
JNZ BLOCK22 
JMP BLOCK23 
BLOCK22:
MOV BX, 1
JMP BLOCK19
BLOCK23:
MOV AX, 3 
MOV WORD PTR BP[-6] , AX 
JMP BLOCK24 
BLOCK24:
MOV BP[-4], DL
MOV BP[-11], CL
MOV AX, WORD PTR BP[-2]  
MOV CX, 2 
XOR DX, DX
IDIV CX 
MOV WORD PTR BP[-14] , AX 
MOV AX, WORD PTR BP[-6]  
CMP AX, WORD PTR BP[-14]  
JL YES9 
MOV BYTE PTR BP[-15] , 0 
JMP CON9 
YES9:
MOV BYTE PTR BP[-15] , 1 
CON9:
TEST BYTE PTR BP[-15] , 1 
JNZ BLOCK25 
JMP BLOCK29 
BLOCK25:
MOV BP[-4], DL
MOV AX, WORD PTR BP[-2]  
XOR DX, DX
DIV WORD PTR BP[-6]  
MOV WORD PTR BP[-8] , DX 
CMP WORD PTR BP[-8] , 0 
JE YES10 
MOV BYTE PTR BP[-9] , 0 
JMP CON10 
YES10:
MOV BYTE PTR BP[-9] , 1 
CON10:
TEST BYTE PTR BP[-9] , 1 
JNZ BLOCK26 
JMP BLOCK27 
BLOCK26:
MOV BX, 0
JMP BLOCK19
BLOCK27:
JMP BLOCK28 
BLOCK28:
MOV AX, WORD PTR BP[-6]  
ADD AX, 2 
MOV WORD PTR BP[-12] , AX 
MOV AX, WORD PTR BP[-12]  
MOV WORD PTR BP[-6] , AX 
JMP BLOCK24 
BLOCK29:
MOV BX, 1
JMP BLOCK19
BLOCK12:
CMP WORD PTR BP[-2] , 1 
JE YES11 
MOV BYTE PTR BP[-4] , 0 
JMP CON11 
YES11:
MOV BYTE PTR BP[-4] , 1 
CON11:
TEST BYTE PTR BP[-4] , 1 
JNZ BLOCK13 
JMP BLOCK14 
BLOCK13:
MOV BX, 1
JMP BLOCK10
BLOCK14:
MOV AX, WORD PTR BP[-2]  
SUB AX, 1 
MOV WORD PTR BP[-6] , AX 
PUSH WORD PTR BP[-6] 
MOV BP[-7], BL
MOV BP[-11], CL
MOV BP[-4], DL
CALL BLOCK9 
MOV BP[-8], BX
JMP BLOCK15 
BLOCK4:
MOV AX, WORD PTR BP[-4]  
MOV CX, 2 
XOR DX, DX
IDIV CX 
MOV BX, AX 
PUSH BX
PUSH WORD PTR BP[-2] 
MOV BP[-10], BX
CALL BLOCK1 
MOV BP[-12], BX
JMP BLOCK5 
GETNUM PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
XOR BX, BX
XOR CX, CX
MOV AH, 1
INT 21H
CMP AL, '-'
JE NEGATIVE_NUMBER_INPUT
XOR SI, SI
JMP POSITIVE_NUMBER_INPUT
NEGATIVE_NUMBER_INPUT:
INT 21H
MOV SI, 1
POSITIVE_NUMBER_INPUT:
CMP AL, '+'
JNE NUMBER_INPUT_LOOP
INT 21H
NUMBER_INPUT_LOOP:
CMP AL, 0DH
JE END_NUMBER_INPUT
CMP AL, '0'
JB INVALID_NUMBER_INPUT_BLOCK
CMP AL, '9'
JA INVALID_NUMBER_INPUT_BLOCK
MOV CL, AL
SUB CL, '0'
MOV AX, BX
MOV BX, 10
MUL BX
MOV BX, AX
ADD BX, CX
MOV AH, 1
INT 21H	
JMP NUMBER_INPUT_LOOP
END_NUMBER_INPUT:
MOV AX, BX
TEST SI, 1
JZ RETURN_FROM_NUMBER_INPUT
MOV SI, -1
IMUL SI
RETURN_FROM_NUMBER_INPUT:
POP BX
POP CX
POP DX
POP SI
RET
INVALID_NUMBER_INPUT_BLOCK:
LEA DX, INVALID_NUMBER_INPUT
MOV AH, 09H
INT 21H
POP BX
POP CX
POP DX
POP SI
CALL GETNUM
RET
GETNUM ENDP
PRINTNUM PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
LEA DI, NUMBER_OUT_PUT_BUFFER
CMP AX, 8000H
JB PRINT_POSITIVE_NUMBER
MOV SI, WORD PTR -1
IMUL SI
MOV BX, AX
MOV DL, '-'
MOV [DI], DL
INC DI
JMP PRINT_NEGATIVE_NUMBER
PRINT_POSITIVE_NUMBER:
MOV BX, AX
PRINT_NEGATIVE_NUMBER:
CMP BX, 30000
JAE LENGTH_MAXIMUM_NUMBER_LENGTH
MOV AX, 10
MOV CX, 1
MOV SI, 10
NUMBER_PRINT_LENGTH_LOOP:
CMP AX, BX
JA END_NUMBER_PRINT_LENGTH
MUL SI
INC CX
JMP NUMBER_PRINT_LENGTH_LOOP
LENGTH_MAXIMUM_NUMBER_LENGTH:
MOV CX, 5
MOV SI, 10
END_NUMBER_PRINT_LENGTH:
MOV AX, BX
ADD DI, CX
MOV BX, DI
DEC DI
XOR DX, DX
NUMBER_PRINT_LOOP:
DIV SI
ADD DL, '0'
MOV [DI], DL
DEC DI
XOR DX, DX
LOOP NUMBER_PRINT_LOOP
END_PRINT_NUMBER:
MOV AL, '$'
MOV [BX], AL
LEA DX, NUMBER_OUT_PUT_BUFFER
MOV AH, 09H
INT 21H
LEA DX, NEW_LINE_CHARS
MOV AH, 09H
INT 21H
POP AX
POP BX
POP CX
POP DX
POP SI
POP DI
RET
PRINTNUM ENDP
PRINTSTRING PROC
PUSH DX
MOV DX, AX
MOV AH, 09H
INT 21H
POP DX
RET
PRINTSTRING ENDP
CODE ENDS
END START
