#include "LexerFsm.h"
#include "Tokens.h"

BOOLEAN is_valid_char(char c) {
	return (c >= 0 && c < CHAR_POSIBILITIES) && Available_Lookup[c];
}

enum State get_next_state(enum State current_state, char c) {
    // return error state if not a valid char
	return is_valid_char(c) ? Lexer_FSM[current_state][c] : ERROR_STATE;
}

static Token_Types state_to_token_lookup[NUM_OF_STATES] = {
    [STATE0] = TOKEN_UNKNOWN,
    [NUMBER] = TOKEN_NUMBER,

    [IDENTIFIER] = TOKEN_IDENTIFIER,
    [B] = TOKEN_IDENTIFIER,
    [BR] = TOKEN_IDENTIFIER,
    [BRE] = TOKEN_IDENTIFIER,
    [BREA] = TOKEN_IDENTIFIER,
    [BREAK] = TOKEN_BREAK,
    [BO] = TOKEN_IDENTIFIER,
    [BOO] = TOKEN_IDENTIFIER,
    [BOOL] = TOKEN_BOOL,
    [C] = TOKEN_IDENTIFIER,
    [CA] = TOKEN_IDENTIFIER,
    [CAL] = TOKEN_IDENTIFIER,
    [CALL] = TOKEN_CALL,
    [CH] = TOKEN_IDENTIFIER,
    [CHA] = TOKEN_IDENTIFIER,
    [CHAN] = TOKEN_IDENTIFIER,
    [CHANG] = TOKEN_IDENTIFIER,
    [CHANGE] = TOKEN_CHANGE,
    [D] = TOKEN_IDENTIFIER,
    [DO] = TOKEN_DO, 
    [E] = TOKEN_IDENTIFIER,
    [EL] = TOKEN_IDENTIFIER,
    [ELS] = TOKEN_IDENTIFIER,
    [ELSE] = TOKEN_ELSE,
    [F] = TOKEN_IDENTIFIER,
    [FA] = TOKEN_IDENTIFIER,
    [FAL] = TOKEN_IDENTIFIER,
    [FALS] = TOKEN_IDENTIFIER,
    [FALSE] = TOKEN_FALSE,
    [FO] = TOKEN_IDENTIFIER,
    [FOR] = TOKEN_FOR, 
    [FU] = TOKEN_IDENTIFIER,
    [FUN] = TOKEN_IDENTIFIER,
    [FUNC] = TOKEN_IDENTIFIER,
    [FUNCT] = TOKEN_IDENTIFIER,
    [FUNCTI] = TOKEN_IDENTIFIER,
    [FUNCTIO] = TOKEN_IDENTIFIER,
    [FUNCTION] = TOKEN_FUNCTION,
    [G] = TOKEN_IDENTIFIER,
    [GE] = TOKEN_IDENTIFIER,
    [GET] = TOKEN_GET,
    [GETS] = TOKEN_GETS, 
    [I] = TOKEN_IDENTIFIER,
    [IF] = TOKEN_IF,
    [IN] = TOKEN_IDENTIFIER,
    [INT] = TOKEN_INT, 
    [P] = TOKEN_IDENTIFIER,
    [PR] = TOKEN_IDENTIFIER,
    [PRI] = TOKEN_IDENTIFIER,
    [PRIN] = TOKEN_IDENTIFIER,
    [PRINT] = TOKEN_PRINT, 
    [R] = TOKEN_IDENTIFIER,
    [RE] = TOKEN_IDENTIFIER,
    [RET] = TOKEN_IDENTIFIER,
    [RETU] = TOKEN_IDENTIFIER,
    [RETUR] = TOKEN_IDENTIFIER,
    [RETURN] = TOKEN_RETURN,
    [RETURNS] = TOKEN_RETURNS,
    [T] = TOKEN_IDENTIFIER,
    [TR] = TOKEN_IDENTIFIER,
    [TRU] = TOKEN_IDENTIFIER,
    [TRUE] = TOKEN_TRUE, 
    [W] = TOKEN_IDENTIFIER,
    [WH] = TOKEN_IDENTIFIER,
    [WHI] = TOKEN_IDENTIFIER,
    [WHIL] = TOKEN_IDENTIFIER,
    [WHILE] = TOKEN_WHILE, 

    [L_PAREN] = TOKEN_LPAREN,
    [R_PAREN] = TOKEN_RPAREN,
    [L_BRACES] = TOKEN_LBRACES,
    [R_BRACES] = TOKEN_RBRACES,
    [COMMA] = TOKEN_COMMA,

    [PLUS] = TOKEN_OPERATOR_PLUS,
    [MINUS] = TOKEN_OPERATOR_MINUS,
    [MULTIPLY] = TOKEN_OPERATOR_MULTIPLY,
    [DIVIDE] = TOKEN_OPERATOR_DIVIDE,
    [ASSIGN] = TOKEN_OPERATOR_ASSIGN,
    [GREATER] = TOKEN_OPERATOR_GREATER,
    [LESS] = TOKEN_OPERATOR_LESS,
    [MODULO] = TOKEN_OPERATOR_MODULO,
    [NOT] = TOKEN_OPERATOR_NOT,
    [AND] = TOKEN_OPERATOR_AND,
    [OR] = TOKEN_OPERATOR_OR,
    [EQUAL] = TOKEN_OPERATOR_EQUAL,
    [NOT_EQUAL] = TOKEN_OPERATOR_NOT_EQUAL,
    [GREATER_EQUAL] = TOKEN_OPERATOR_GREATER_EQUAL,
    [LESS_EQUAL] = TOKEN_OPERATOR_LESS_EQUAL,
    [ALSO] = TOKEN_OPERATOR_ALSO,
    [EITHER] = TOKEN_OPERATOR_EITHER,

    [STRING_LITERAL] = TOKEN_STRING_LITERAL,
    [STRING_LITERAL_END] = TOKEN_STRING_LITERAL,
    [COMMENT] = TOKEN_UNKNOWN,
    [COMMENT_END] = TOKEN_UNKNOWN,

    [ERROR] = TOKEN_UNKNOWN,
};

Token_Types convert_state_to_token_type(enum State state) {
	return state_to_token_lookup[state];
}

// ignored state is a state that doesnt have a specific token assigned
BOOLEAN is_ignored_state(enum State state) {
	return state_to_token_lookup[state] == TOKEN_UNKNOWN;
}